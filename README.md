# Домашнее задание к занятию «Динамическое программирование и жадность»

Выполнив это задание, вы сможете вспомнить и оптимизировать вычисление чисел Фибоначчи.

### Цель задания

1. Научиться оценивать сложность алгоритмов по скорости и памяти.
2. Научиться ускорять алгоритм за счёт использования допольнительной памяти.


### Задание 1

[Снова числа Фибоначчи](01)

<details>
  
# Задача 1. Снова числа Фибоначчи

Напишите ещё раз программу, которая реализует рекурсивный подсчёт чисел Фибоначчи. Не заглядывайте в ваше предыдущее решение, постарайтесь написать его заново.

Кроме написания кода нужно оценить сложность вашего алгоритма вычисления n-го числа Фибоначчи по скорости и по памяти.

#### Подсказки

> Не читайте этот раздел сразу. Попытайтесь сначала решить задачу самостоятельно :)

<details>

<summary>Что использовать для решения.</summary>

Чтобы оценить сложность алгоритма по скорости, нарисуйте где-нибудь, например, на бумажке, дерево вызовов функции. Постройте деревья вызовов для нескольких небольших значений, идущих подряд, и посмотрите, как меняется это количество. Затем подберите функцию, которая растёт примерно с такой же скоростью.

</details>



</details>




### Задание 2

[Ускоряем Фибоначчи](02)

<details>
# Задача 2. Ускоряем Фибоначчи

Наивное решение задачи по вычислению чисел Фибоначчи является довольно дорогим по времени, при этом совсем не использует дополнительную память. Давайте исправим это с помощью применения динамического программирования к рекурсии.

Ваша задача — изменить алгоритм вычисления n-го числа Фибоначчи так, чтобы сложность алгоритма по скорости составляла `O(n)` и по памяти тоже была порядка `O(n)`.

#### Подсказки

> Не читайте этот раздел сразу. Попытайтесь сначала решить задачу самостоятельно :)

<details>

<summary>Что использовать для решения.</summary>

Для уменьшения времени работы алгоритма вычисления n-го числа Фибоначчи вам нужно избавиться от того, что занимает так много времени — вычисления одних и тех же предыдущиих элементов последовательности. Для этого нужно запоминать, например, в массив, уже вычисленные элементы последовательности.

</details>

</details>
